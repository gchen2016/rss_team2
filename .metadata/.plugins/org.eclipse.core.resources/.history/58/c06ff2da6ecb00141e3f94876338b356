package Grasping;

import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.List;

public class InverseKinematics {

	protected static double ARM_LENGTH = 0.245;
	protected static double WRIST_LENGTH = 0.18;
	
	public static double getTheta(double zsol)
		{
		double theta = Math.acos(zsol/ARM_LENGTH);		//check that x and y give same solution??
		return theta;
		}
	
	public static double getPhi(double zsol, double ztarg)
		{
		double phi = Math.acos((ztarg-zsol)/WRIST_LENGTH);
		return phi;
		}
	
	/**
	 * 
	 * @param X negative wrt arm joint
	 * @param Z negative wrt arm joint
	 * @return solutions (2)
	 */
	
	public static double[] getPositions(double xtarg, double ztarg)
		{
		double[] Zs = new double[2];
		
		double A = (Math.pow(WRIST_LENGTH,2) - Math.pow(ARM_LENGTH,2)
					-Math.pow(xtarg,2) -Math.pow(ztarg,2))/(-2*xtarg); 
		double rat = ztarg/xtarg;
		
		System.out.println(A + " " + rat);

		
		double plain = -A*rat/2;
		double plusmin = Math.sqrt(Math.pow(A*rat,2)/4 - Math.pow(A,2)/2);
		
		System.out.println(plain + " " + plusmin);

		
		Zs[0] = plain+plusmin;
		Zs[1] = plain-plusmin;
		
		return Zs;
		}
	
	public static double[] getThetaPhi(double xtarg, double ztarg, double currTheta, double currPhi)
		{
		double[] Zs = getPositions(xtarg, ztarg);		//always 2 solutions
		
		System.out.println(Arrays.toString(Zs));

		
		double theta1 = getTheta(Zs[0]);
		double phi1 = getPhi(Zs[0], ztarg);
		double distance1 = Math.abs(currTheta-theta1)+Math.abs(currPhi-phi1);
		
		double theta2 = getTheta(Zs[1]);
		double phi2 = getPhi(Zs[1], ztarg);
		double distance2 = Math.abs(currTheta-theta2)+Math.abs(currPhi-phi2);
		
		if (distance1<distance2) return new double[]{theta1,phi1};
		else return new double[]{theta2,phi2};
		
		}
	
	public static void main(String[] args)
		{
		System.out.println(Arrays.toString(getThetaPhi(-ARM_LENGTH - WRIST_LENGTH, 0, 0, 0)));
		}
}
